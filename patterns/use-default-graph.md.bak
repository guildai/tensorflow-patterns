---
title: Use default graph
scope: Code convention
summary: >

    Rely on TensorFlow's default graph rather than use new graphs as a
    context manager.

---

Some TensorFlow examples use this pattern:

``` python
with tf.Graph() as g:
    # perform operations that implicitly modify the default graph
    ...
```

This pattern suggests using the default graph implicitly in all cases
and not use graphs as context managers.

- It's easy to forget to use alterantive graphs when executing
  TensorFlow code --- these ommissions result in hard-to-find bugs

- If you need to work with multiple graphs, consider defining all
  operations in a single graph or using separate scripts

## Example

This example relies on TensorFlow's "default graph" which is
practically speaking a global variable per Python process.

``` python
def init_model():
    global x, y
    x = tf.placeholder(tf.float32, [None, 784])
    W = tf.Variable(tf.zeros([784, 10]))
    b = tf.Variable(tf.zeros([10]))
    y = tf.nn.softmax(tf.matmul(x, W) + b)
```

## Anti-pattern <small>(avoid)</small>

This example uses a newly created graph and is careful to run
graph-modifying code within a context manager:

``` python
def init_model(g):
    global x, y
    with g:
        x = tf.placeholder(tf.float32, [None, 784])
        W = tf.Variable(tf.zeros([784, 10]))
        b = tf.Variable(tf.zeros([10]))
        y = tf.nn.softmax(tf.matmul(x, W) + b)
    
def init():
    g = tf.Graph()
    init_model(g)
```
